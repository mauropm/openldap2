Index: clients/tools/ldapexop.c
===================================================================
RCS file: clients/tools/ldapexop.c
diff -N clients/tools/ldapexop.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ clients/tools/ldapexop.c	1 Feb 2007 16:59:34 -0000
@@ -0,0 +1,329 @@
+/* ldapexop.c -- a tool for performing well-known extended operations */
+/* $OpenLDAP: pkg/ldap/clients/tools/ldapexop.c,v 1.11 2007/01/02 19:00:50 kurt Exp $ */
+/* This work is part of OpenLDAP Software <http://www.openldap.org/>.
+ *
+ * Copyright 2005-2007 The OpenLDAP Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted only as authorized by the OpenLDAP
+ * Public License.
+ *
+ * A copy of this license is available in the file LICENSE in the
+ * top-level directory of the distribution or, alternatively, at
+ * <http://www.OpenLDAP.org/license.html>.
+ */
+/* ACKNOWLEDGEMENTS:
+ * This work was originally developed by Pierangelo Masarati for inclusion
+ * in OpenLDAP Software based, in part, on other client tools.
+ */
+
+#include "portable.h"
+
+#include <stdio.h>
+
+#include <ac/stdlib.h>
+
+#include <ac/ctype.h>
+#include <ac/socket.h>
+#include <ac/string.h>
+#include <ac/time.h>
+#include <ac/unistd.h>
+
+#include <ldap.h>
+#include "ldif.h"
+#include "lutil.h"
+#include "lutil_ldap.h"
+#include "ldap_defaults.h"
+
+#include "common.h"
+
+void
+usage( void )
+{
+	fprintf( stderr, _("Issue LDAP extended operations\n\n"));
+	fprintf( stderr, _("usage: %s [options] <oid|oid:data|oid::b64data>\n"), prog);
+	tool_common_usage();
+	exit( EXIT_FAILURE );
+}
+
+
+const char options[] = ""
+	"d:D:e:h:H:InO:o:p:QR:U:vVw:WxX:y:Y:Z";
+
+int
+handle_private_option( int i )
+{
+	switch ( i ) {
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+
+int
+main( int argc, char *argv[] )
+{
+	int		rc;
+	char		*user = NULL;
+
+	LDAP		*ld = NULL;
+
+	char		*matcheddn = NULL, *text = NULL, **refs = NULL;
+	int		id, code;
+	LDAPMessage	*res;
+
+	tool_init();
+	prog = lutil_progname( "ldapexop", argc, argv );
+
+	/* LDAPv3 only */
+	protocol = LDAP_VERSION3;
+
+	tool_args( argc, argv );
+
+	if ( argc - optind < 1 ) {
+		usage();
+	}
+
+	if ( pw_file || want_bindpw ) {
+		if ( pw_file ) {
+			rc = lutil_get_filed_password( pw_file, &passwd );
+			if( rc ) return EXIT_FAILURE;
+		} else {
+			passwd.bv_val = getpassphrase( _("Enter LDAP Password: ") );
+			passwd.bv_len = passwd.bv_val ? strlen( passwd.bv_val ) : 0;
+		}
+	}
+
+	ld = tool_conn_setup( 0, 0 );
+
+	tool_bind( ld );
+
+	argv += optind;
+	argc -= optind;
+
+	if ( strcasecmp( argv[ 0 ], "whoami" ) == 0 ) {
+		switch ( argc ) {
+		case 2:
+			user = argv[ 1 ];
+
+		case 1:
+			break;
+
+		default:
+			fprintf( stderr, "need [user]\n\n" );
+			usage();
+		}
+
+		tool_server_controls( ld, NULL, 0 );
+
+		rc = ldap_whoami( ld, NULL, NULL, &id ); 
+		if ( rc != LDAP_SUCCESS ) {
+			tool_perror( "ldap_extended_operation", rc, NULL, NULL, NULL, NULL );
+			rc = EXIT_FAILURE;
+			goto skip;
+		}
+
+	} else if ( strcasecmp( argv[ 0 ], "cancel" ) == 0 ) {
+		int		cancelid;
+
+		switch ( argc ) {
+		case 2:
+			 if ( lutil_atoi( &cancelid, argv[ 1 ] ) != 0 || cancelid < 0 ) {
+				fprintf( stderr, "invalid cancelid=%s\n\n", argv[ 1 ] );
+				usage();
+			}
+			break;
+
+		default:
+			fprintf( stderr, "need cancelid\n\n" );
+			usage();
+		}
+
+		rc = ldap_cancel( ld, cancelid, NULL, NULL, &id );
+		if ( rc != LDAP_SUCCESS ) {
+			tool_perror( "ldap_cancel", rc, NULL, NULL, NULL, NULL );
+			rc = EXIT_FAILURE;
+			goto skip;
+		}
+
+	} else if ( strcasecmp( argv[ 0 ], "passwd" ) == 0 ) {
+		fprintf( stderr, "use ldappasswd(1) instead.\n\n", argv[ 0 ] );
+		usage();
+		/* TODO? */
+
+	} else {
+		char *p;
+
+		if ( argc != 1 ) {
+			usage();
+		}
+
+		p = strchr( argv[ 0 ], ':' );
+		if ( p == argv[ 0 ] ) {
+			usage();
+		}
+
+		if ( p != NULL )
+			*p++ = '\0';
+
+		if ( tool_is_oid( argv[ 0 ] ) ) {
+			struct berval	reqdata;
+			struct berval	type;
+			struct berval	value;
+			int		freeval;
+
+			if ( p != NULL ) {
+				p[ -1 ] = ':';
+				ldif_parse_line2( argv[ 0 ], &type, &value, &freeval );
+				p[ -1 ] = '\0';
+
+				if ( freeval ) {
+					reqdata = value;
+				} else {
+					ber_dupbv( &reqdata, &value );
+				}
+			}
+
+
+			tool_server_controls( ld, NULL, 0 );
+
+			rc = ldap_extended_operation( ld, argv[ 0 ], p ? &reqdata : NULL, NULL, NULL, &id );
+			if ( rc != LDAP_SUCCESS ) {
+				tool_perror( "ldap_extended_operation", rc, NULL, NULL, NULL, NULL );
+				rc = EXIT_FAILURE;
+				goto skip;
+			}
+		} else {
+			fprintf( stderr, "unknown exop \"%s\"\n\n", argv[ 0 ] );
+			usage();
+		}
+	}
+
+	for ( ; ; ) {
+		struct timeval	tv;
+
+		if ( tool_check_abandon( ld, id ) ) {
+			return LDAP_CANCELLED;
+		}
+
+		tv.tv_sec = 0;
+		tv.tv_usec = 100000;
+
+		rc = ldap_result( ld, LDAP_RES_ANY, LDAP_MSG_ALL, &tv, &res );
+		if ( rc < 0 ) {
+			tool_perror( "ldap_result", rc, NULL, NULL, NULL, NULL );
+			rc = EXIT_FAILURE;
+			goto skip;
+		}
+
+		if ( rc != 0 ) {
+			break;
+		}
+	}
+
+	rc = ldap_parse_result( ld, res,
+		&code, &matcheddn, &text, &refs, NULL, 0 );
+	if ( rc == LDAP_SUCCESS ) {
+		rc = code;
+	}
+
+	if ( rc != LDAP_SUCCESS ) {
+		tool_perror( "ldap_parse_result", rc, NULL, matcheddn, text, refs );
+		rc = EXIT_FAILURE;
+		goto skip;
+	}
+
+	if ( strcasecmp( argv[ 0 ], "whoami" ) == 0 ) {
+		char		*retoid = NULL;
+		struct berval	*retdata = NULL;
+
+		rc = ldap_parse_extended_result( ld, res, &retoid, &retdata, 1 );
+
+		if ( rc != LDAP_SUCCESS ) {
+			tool_perror( "ldap_parse_extended_result", rc, NULL, NULL, NULL, NULL );
+			rc = EXIT_FAILURE;
+			goto skip;
+		}
+
+		if ( retdata != NULL ) {
+			if ( retdata->bv_len == 0 ) {
+				printf(_("anonymous\n") );
+			} else {
+				printf("%s\n", retdata->bv_val );
+			}
+		}
+
+		ber_memfree( retoid );
+		ber_bvfree( retdata );
+
+	} else if ( strcasecmp( argv[ 0 ], "cancel" ) == 0 ) {
+		/* no extended response; returns specific errors */
+		assert( 0 );
+
+	} else if ( strcasecmp( argv[ 0 ], "passwd" ) == 0 ) {
+		/* TODO */
+
+	} else if ( tool_is_oid( argv[ 0 ] ) ) {
+		char		*retoid = NULL;
+		struct berval	*retdata = NULL;
+
+		if( ldif < 2 ) {
+			printf(_("# extended operation response\n"));
+		}
+
+		rc = ldap_parse_extended_result( ld, res, &retoid, &retdata, 1 );
+		if ( rc != LDAP_SUCCESS ) {
+			tool_perror( "ldap_parse_extended_result", rc, NULL, NULL, NULL, NULL );
+			rc = EXIT_FAILURE;
+			goto skip;
+		}
+
+		if ( ldif < 2 && retoid != NULL ) {
+			tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+				"oid", retoid, strlen(retoid) );
+		}
+
+		ber_memfree( retoid );
+
+		if( retdata != NULL ) {
+			if ( ldif < 2 ) {
+				tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_BINARY,
+					"data", retdata->bv_val, retdata->bv_len );
+			}
+
+			ber_bvfree( retdata );
+		}
+	}
+
+	if( verbose || ( code != LDAP_SUCCESS ) || matcheddn || text || refs ) {
+		printf( _("Result: %s (%d)\n"), ldap_err2string( code ), code );
+
+		if( text && *text ) {
+			printf( _("Additional info: %s\n"), text );
+		}
+
+		if( matcheddn && *matcheddn ) {
+			printf( _("Matched DN: %s\n"), matcheddn );
+		}
+
+		if( refs ) {
+			int i;
+			for( i=0; refs[i]; i++ ) {
+				printf(_("Referral: %s\n"), refs[i] );
+			}
+		}
+	}
+
+	ber_memfree( text );
+	ber_memfree( matcheddn );
+	ber_memvfree( (void **) refs );
+
+skip:
+	/* disconnect from server */
+	tool_unbind( ld );
+	tool_destroy();
+
+	return code == LDAP_SUCCESS ? EXIT_SUCCESS : EXIT_FAILURE;
+}
Index: clients/tools/Makefile.in
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/clients/tools/Makefile.in,v
retrieving revision 1.44
retrieving revision 1.45
diff -u -r1.44 -r1.45
--- clients/tools/Makefile.in	3 Jan 2006 22:12:00 -0000	1.44
+++ clients/tools/Makefile.in	6 Jan 2006 16:47:36 -0000	1.45
@@ -14,9 +14,11 @@
 ## <http://www.OpenLDAP.org/license.html>.
 
 SRCS	= ldapsearch.c ldapmodify.c ldapdelete.c ldapmodrdn.c \
-		ldappasswd.c ldapwhoami.c ldapcompare.c common.c
+		ldappasswd.c ldapwhoami.c ldapcompare.c \
+		ldapexop.c common.c
 OBJS	= ldapsearch.o ldapmodify.o ldapdelete.o ldapmodrdn.o \
-		ldappasswd.o ldapwhoami.o ldapcompare.o common.o
+		ldappasswd.o ldapwhoami.o ldapcompare.o \
+		ldapexop.o common.o
 
 LDAP_INCDIR= ../../include       
 LDAP_LIBDIR= ../../libraries
@@ -27,10 +29,10 @@
 XXLIBS	= $(SECURITY_LIBS) $(LUTIL_LIBS)
 
 XSRCS	= ldsversion.c ldmversion.c lddversion.c ldrversion.c \
-	ldpversion.c ldwversion.c ldcversion.c
+	ldpversion.c ldwversion.c ldcversion.c ldeversion.c
 
 PROGRAMS = ldapsearch ldapmodify ldapdelete ldapmodrdn \
-	ldappasswd ldapwhoami ldapcompare
+	ldappasswd ldapwhoami ldapcompare ldapexop
 
 
 ldapsearch:	ldsversion.o
@@ -54,6 +56,9 @@
 ldapcompare: ldcversion.o
 	$(LTLINK) -o $@ ldapcompare.o common.o ldcversion.o $(LIBS)
 
+ldapexop: ldeversion.o
+	$(LTLINK) -o $@ ldapexop.o common.o ldeversion.o $(LIBS)
+
 ldsversion.c: Makefile
 	@-$(RM) $@
 	$(MKVERSION) $(MKVOPTS) ldapsearch > $@
@@ -96,6 +101,12 @@
 
 ldcversion.o: ldapcompare.o common.o $(XLIBS)
 
+ldeversion.c: Makefile
+	@-$(RM) $@
+	$(MKVERSION) $(MKVOPTS) ldapexop > $@
+
+ldeversion.o: ldapexop.o common.o $(XLIBS)
+
 install-local:	FORCE
 	-$(MKDIR) $(DESTDIR)$(bindir)
 	@(								\
Index: clients/tools/common.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/clients/tools/common.c,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- clients/tools/common.c	3 Jan 2006 22:12:00 -0000	1.65
+++ clients/tools/common.c	6 Jan 2006 15:20:24 -0000	1.66
@@ -1511,3 +1511,34 @@
 	return( 0 );
 }
 
+int
+tool_is_oid( const char *s )
+{
+	int		first = 1;
+
+	if ( !isdigit( s[ 0 ] ) ) {
+		return 0;
+	}
+
+	for ( ; s[ 0 ]; s++ ) {
+		if ( s[ 0 ] == '.' ) {
+			if ( s[ 1 ] == '\0' ) {
+				return 0;
+			}
+			first = 1;
+			continue;
+		}
+
+		if ( !isdigit( s[ 0 ] ) ) {
+			return 0;
+		}
+
+		if ( first == 1 && s[ 0 ] == '0' && s[ 1 ] != '.' ) {
+			return 0;
+		}
+		first = 0;
+	}
+
+	return 1;
+}
+
Index: clients/tools/common.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/clients/tools/common.c,v
retrieving revision 1.57
retrieving revision 1.59
diff -u -r1.57 -r1.59
--- clients/tools/common.c	17 Nov 2005 23:18:53 -0000	1.57
+++ clients/tools/common.c	23 Nov 2005 00:18:18 -0000	1.59
@@ -42,6 +42,8 @@
 
 #include <ldap.h>
 
+#include "ldif.h"
+#include "lutil.h"
 #include "lutil_ldap.h"
 #include "ldap_defaults.h"
 #include "ldap_pvt.h"
@@ -99,6 +101,7 @@
 int   protocol = -1;
 int   verbose = 0;
 int   version = 0;
+int   ldif = 0;
 
 #ifdef LDAP_CONTROL_X_CHAINING_BEHAVIOR
 int chaining = 0;
@@ -1301,3 +1304,205 @@
 	return 0;
 }
 
+void tool_print_ctrls(
+	LDAP		*ld,
+	LDAPControl	**ctrls )
+{
+	int	i;
+	char	*ptr;
+
+	for ( i = 0; ctrls[i] != NULL; i++ ) {
+		/* control: OID criticality base64value */
+		struct berval b64 = BER_BVNULL;
+		ber_len_t len;
+		char *str;
+
+		len = ldif ? 2 : 0;
+		len += strlen( ctrls[i]->ldctl_oid );
+
+		/* add enough for space after OID and the critical value itself */
+		len += ctrls[i]->ldctl_iscritical
+			? sizeof("true") : sizeof("false");
+
+		/* convert to base64 */
+		if ( ctrls[i]->ldctl_value.bv_len ) {
+			b64.bv_len = LUTIL_BASE64_ENCODE_LEN(
+				ctrls[i]->ldctl_value.bv_len ) + 1;
+			b64.bv_val = ber_memalloc( b64.bv_len + 1 );
+
+			b64.bv_len = lutil_b64_ntop(
+				(unsigned char *) ctrls[i]->ldctl_value.bv_val,
+				ctrls[i]->ldctl_value.bv_len,
+				b64.bv_val, b64.bv_len );
+		}
+
+		if ( b64.bv_len ) {
+			len += 1 + b64.bv_len;
+		}
+
+		ptr = str = malloc( len + 1 );
+		if ( ldif ) {
+			ptr = lutil_strcopy( ptr, ": " );
+		}
+		ptr = lutil_strcopy( ptr, ctrls[i]->ldctl_oid );
+		ptr = lutil_strcopy( ptr, ctrls[i]->ldctl_iscritical
+			? " true" : " false" );
+
+		if ( b64.bv_len ) {
+			ptr = lutil_strcopy( ptr, " " );
+			ptr = lutil_strcopy( ptr, b64.bv_val );
+		}
+
+		if ( ldif < 2 ) {
+			tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+				"control", str, len );
+		}
+
+		free( str );
+		if ( b64.bv_len ) {
+			ber_memfree( b64.bv_val );
+		}
+
+		/* known controls */
+		if ( strcmp( ctrls[i]->ldctl_oid, LDAP_CONTROL_PRE_READ ) == 0
+			|| strcmp( ctrls[i]->ldctl_oid, LDAP_CONTROL_POST_READ ) == 0 )
+		{
+			BerElement	*ber;
+			struct berval	bv;
+			struct berval	what;
+
+			if ( strcmp( ctrls[i]->ldctl_oid, LDAP_CONTROL_PRE_READ ) == 0 ) {
+				BER_BVSTR( &what, "preread" );
+
+			} else {
+				BER_BVSTR( &what, "postread" );
+			}
+
+			tool_write_ldif( LDIF_PUT_COMMENT, "==> ", what.bv_val, what.bv_len );
+			ber = ber_init( &ctrls[i]->ldctl_value );
+			if ( ber == NULL ) {
+				/* ... */
+			} else if ( ber_scanf( ber, "{m{" /*}}*/, &bv ) == LBER_ERROR ) {
+				/* ... */
+			} else {
+				tool_write_ldif( LDIF_PUT_VALUE, "dn", bv.bv_val, bv.bv_len );
+
+				while ( ber_scanf( ber, "{m" /*}*/, &bv ) != LBER_ERROR ) {
+					int		i;
+					BerVarray	vals = NULL;
+
+					if ( ber_scanf( ber, "[W]", &vals ) == LBER_ERROR || vals == NULL ) {
+						/* error? */
+						continue;
+					}
+				
+					for ( i = 0; vals[ i ].bv_val != NULL; i++ ) {
+						tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+							bv.bv_val, vals[ i ].bv_val, vals[ i ].bv_len );
+					}
+
+					ber_bvarray_free( vals );
+				}
+			}
+
+			if ( ber != NULL ) {
+				ber_free( ber, 1 );
+			}
+
+			tool_write_ldif( LDIF_PUT_COMMENT, "<== ", what.bv_val, what.bv_len );
+
+#ifdef LDAP_CONTROL_PAGEDRESULTS
+		} else if ( strcmp( ctrls[i]->ldctl_oid, LDAP_CONTROL_PAGEDRESULTS ) == 0 ) {
+			BerElement	*ber;
+			struct berval	cookie;
+			int		size;
+			
+			ber = ber_init( &ctrls[i]->ldctl_value );
+			if ( ber_scanf( ber, "{im}", &size, &cookie ) == LBER_ERROR ) {
+				/* ... */
+			} else {
+				char	buf[ BUFSIZ ], *ptr = buf;
+
+				if ( size > 0 ) {
+					ptr += snprintf( ptr, sizeof( buf ) - ( ptr - buf ),
+						"estimate=%d", size );
+				}
+
+				if ( cookie.bv_len > 0 ) {
+					struct berval	bv;
+
+					bv.bv_len = LUTIL_BASE64_ENCODE_LEN(
+						cookie.bv_len ) + 1;
+					bv.bv_val = ber_memalloc( bv.bv_len + 1 );
+
+					bv.bv_len = lutil_b64_ntop(
+						(unsigned char *) cookie.bv_val,
+						cookie.bv_len,
+						bv.bv_val, bv.bv_len );
+
+					ptr += snprintf( ptr, sizeof( buf ) - ( ptr - buf ),
+						"%scookie=%s", ptr == buf ? "" : " ",
+						bv.bv_val );
+
+					ber_memfree( bv.bv_val );
+				}
+
+				tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+					"pagedresults", buf, ptr - buf );
+			}
+
+			if ( ber != NULL ) {
+				ber_free( ber, 1 );
+			}
+#endif /* LDAP_CONTROL_PAGEDRESULTS */
+
+#ifdef LDAP_CONTROL_PASSWORDPOLICYREQUEST
+		} else if ( strcmp( ctrls[i]->ldctl_oid, LDAP_CONTROL_PASSWORDPOLICYRESPONSE ) == 0 ) {
+			int expire = 0, grace = 0, rc;
+			LDAPPasswordPolicyError	pperr;
+
+			rc = ldap_parse_passwordpolicy_control( ld, ctrls[ i ],
+				&expire, &grace, &pperr );
+			if ( rc == LDAP_SUCCESS ) {
+				char	buf[ BUFSIZ ], *ptr = buf;
+
+				if ( expire != -1 ) {
+					ptr += snprintf( ptr, sizeof( buf ) - ( ptr - buf ),
+						"expire=%d", expire );
+				}
+
+				if ( grace != -1 ) {
+					ptr += snprintf( ptr, sizeof( buf ) - ( ptr - buf ),
+						"%sgrace=%d", ptr == buf ? "" : " ", grace );
+				}
+
+				if ( pperr != PP_noError ) {
+					ptr += snprintf( ptr, sizeof( buf ) - ( ptr - buf ),
+						"%serror=%s", ptr == buf ? "" : " ",
+						ldap_passwordpolicy_err2txt( pperr ) );
+				}
+
+				tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+					"ppolicy", buf, ptr - buf );
+			}
+		}
+#endif /* LDAP_CONTROL_PASSWORDPOLICYREQUEST */
+
+	}
+}
+
+int
+tool_write_ldif( int type, char *name, char *value, ber_len_t vallen )
+{
+	char	*ldif;
+
+	if (( ldif = ldif_put( type, name, value, vallen )) == NULL ) {
+		return( -1 );
+	}
+
+	fputs( ldif, stdout );
+	ber_memfree( ldif );
+
+	return( 0 );
+}
+
Index: clients/tools/common.h
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/clients/tools/common.h,v
retrieving revision 1.19
retrieving revision 1.23
diff -u -r1.19 -r1.23
--- clients/tools/common.h	16 Nov 2005 20:50:51 -0000	1.19
+++ clients/tools/common.h	6 Jan 2006 15:20:24 -0000	1.23
@@ -63,6 +63,8 @@
 extern int   verbose;
 extern int   version;
 
+extern int   ldif;
+
 /* Defined in common.c, set in main() */
 extern char *prog;
 extern const char __Version[];
@@ -89,6 +91,10 @@
 	const char *matched,
 	const char *info,
 	char **refs ));
+void tool_print_ctrls LDAP_P(( LDAP *ld, LDAPControl **ctrls ));
+int tool_write_ldif LDAP_P(( int type, char *name, char *value, ber_len_t vallen ));
+int tool_is_oid LDAP_P(( const char *s ));
+
 
 LDAP_END_DECL
 
Index: clients/tools/ldapsearch.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/clients/tools/ldapsearch.c,v
retrieving revision 1.220
retrieving revision 1.222
diff -u -r1.220 -r1.222
--- clients/tools/ldapsearch.c	16 Nov 2005 20:50:51 -0000	1.220
+++ clients/tools/ldapsearch.c	23 Nov 2005 00:18:19 -0000	1.222
@@ -178,15 +178,6 @@
 	LDAPMessage *result,
 	int search );
 
-static void print_ctrls(
-	LDAPControl **ctrls );
-
-static int write_ldif LDAP_P((
-	int type,
-	char *name,
-	char *value,
-	ber_len_t vallen ));
-
 static int dosearch LDAP_P((
 	LDAP	*ld,
 	char	*base,
@@ -204,7 +195,7 @@
 static char *urlpre = NULL;
 static char	*base = NULL;
 static char	*sortattr = NULL;
-static int  includeufn, vals2tmp = 0, ldif = 0;
+static int  includeufn, vals2tmp = 0;
 
 static int subentries = 0, valuesReturnFilter = 0;
 static char	*vrFilter = NULL;
@@ -1305,9 +1296,9 @@
 
 	if ( ldif < 2 ) {
 		ufn = ldap_dn2ufn( bv.bv_val );
-		write_ldif( LDIF_PUT_COMMENT, NULL, ufn, ufn ? strlen( ufn ) : 0 );
+		tool_write_ldif( LDIF_PUT_COMMENT, NULL, ufn, ufn ? strlen( ufn ) : 0 );
 	}
-	write_ldif( LDIF_PUT_VALUE, "dn", bv.bv_val, bv.bv_len );
+	tool_write_ldif( LDIF_PUT_VALUE, "dn", bv.bv_val, bv.bv_len );
 
 	rc = ldap_get_entry_controls( ld, entry, &ctrls );
 	if( rc != LDAP_SUCCESS ) {
@@ -1317,7 +1308,7 @@
 	}
 
 	if( ctrls ) {
-		print_ctrls( ctrls );
+		tool_print_ctrls( ld, ctrls );
 		ldap_controls_free( ctrls );
 	}
 
@@ -1325,7 +1316,7 @@
 		if( ufn == NULL ) {
 			ufn = ldap_dn2ufn( bv.bv_val );
 		}
-		write_ldif( LDIF_PUT_VALUE, "ufn", ufn, ufn ? strlen( ufn ) : 0 );
+		tool_write_ldif( LDIF_PUT_VALUE, "ufn", ufn, ufn ? strlen( ufn ) : 0 );
 	}
 
 	if( ufn != NULL ) ldap_memfree( ufn );
@@ -1339,7 +1330,7 @@
 		if (bv.bv_val == NULL) break;
 
 		if ( attrsonly ) {
-			write_ldif( LDIF_PUT_NOVALUE, bv.bv_val, NULL, 0 );
+			tool_write_ldif( LDIF_PUT_NOVALUE, bv.bv_val, NULL, 0 );
 
 		} else if ( bvals ) {
 			for ( i = 0; bvals[i].bv_val != NULL; i++ ) {
@@ -1379,10 +1370,10 @@
 						&tmpfname[strlen(tmpdir) + sizeof(LDAP_DIRSEP) - 1] );
 
 					urlize( url );
-					write_ldif( LDIF_PUT_URL, bv.bv_val, url, strlen( url ));
+					tool_write_ldif( LDIF_PUT_URL, bv.bv_val, url, strlen( url ));
 
 				} else {
-					write_ldif( LDIF_PUT_VALUE, bv.bv_val,
+					tool_write_ldif( LDIF_PUT_VALUE, bv.bv_val,
 						bvals[ i ].bv_val, bvals[ i ].bv_len );
 				}
 			}
@@ -1417,14 +1408,14 @@
 	if( refs ) {
 		int i;
 		for( i=0; refs[i] != NULL; i++ ) {
-			write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+			tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
 				"ref", refs[i], strlen(refs[i]) );
 		}
 		ber_memvfree( (void **) refs );
 	}
 
 	if( ctrls ) {
-		print_ctrls( ctrls );
+		tool_print_ctrls( ld, ctrls );
 		ldap_controls_free( ctrls );
 	}
 }
@@ -1450,14 +1441,14 @@
 	}
 
 	if ( ldif < 2 ) {
-		write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+		tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
 			"extended", retoid, retoid ? strlen(retoid) : 0 );
 	}
 	ber_memfree( retoid );
 
 	if(retdata) {
 		if ( ldif < 2 ) {
-			write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_BINARY,
+			tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_BINARY,
 				"data", retdata->bv_val, retdata->bv_len );
 		}
 		ber_bvfree( retdata );
@@ -1488,7 +1479,7 @@
 	}
 
 	if ( ldif < 2 ) {
-		write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
+		tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
 			"partial", retoid, retoid ? strlen(retoid) : 0 );
 	}
 
@@ -1496,7 +1487,7 @@
 
 	if( retdata ) {
 		if ( ldif < 2 ) {
-			write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_BINARY,
+			tool_write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_BINARY,
 				"data", retdata->bv_val, retdata->bv_len );
 		}
 
@@ -1504,7 +1495,7 @@
 	}
 
 	if( ctrls ) {
-		print_ctrls( ctrls );
+		tool_print_ctrls( ld, ctrls );
 		ldap_controls_free( ctrls );
 	}
 }
@@ -1548,7 +1539,7 @@
 	if( matcheddn ) {
 		if( *matcheddn ) {
 		if( !ldif ) {
-			write_ldif( LDIF_PUT_VALUE,
+			tool_write_ldif( LDIF_PUT_VALUE,
 				"matchedDN", matcheddn, strlen(matcheddn) );
 		} else {
 			fprintf( stderr, _("Matched DN: %s\n"), matcheddn );
@@ -1561,7 +1552,7 @@
 	if( text ) {
 		if( *text ) {
 		if( !ldif ) {
-			write_ldif( LDIF_PUT_TEXT, "text",
+			tool_write_ldif( LDIF_PUT_TEXT, "text",
 				text, strlen(text) );
 		} else {
 			fprintf( stderr, _("Additional information: %s\n"), text );
@@ -1575,7 +1566,7 @@
 		int i;
 		for( i=0; refs[i] != NULL; i++ ) {
 			if( !ldif ) {
-				write_ldif( LDIF_PUT_VALUE, "ref", refs[i], strlen(refs[i]) );
+				tool_write_ldif( LDIF_PUT_VALUE, "ref", refs[i], strlen(refs[i]) );
 			} else {
 				fprintf( stderr, _("Referral: %s\n"), refs[i] );
 			}
@@ -1585,89 +1576,13 @@
 	}
 
 	if( ctrls ) {
-		print_ctrls( ctrls );
+		tool_print_ctrls( ld, ctrls );
 		ldap_controls_free( ctrls );
 	}
 
 	return err;
 }
 
-static void print_ctrls(
-	LDAPControl **ctrls )
-{
-	int i;
-	for(i=0; ctrls[i] != NULL; i++ ) {
-		/* control: OID criticality base64value */
-		struct berval *b64 = NULL;
-		ber_len_t len;
-		char *str;
-
-		len = ldif ? 2 : 0;
-		len += strlen( ctrls[i]->ldctl_oid );
-
-		/* add enough for space after OID and the critical value itself */
-		len += ctrls[i]->ldctl_iscritical
-			? sizeof("true") : sizeof("false");
-
-		/* convert to base64 */
-		if( ctrls[i]->ldctl_value.bv_len ) {
-			b64 = ber_memalloc( sizeof(struct berval) );
-			
-			b64->bv_len = LUTIL_BASE64_ENCODE_LEN(
-				ctrls[i]->ldctl_value.bv_len ) + 1;
-			b64->bv_val = ber_memalloc( b64->bv_len + 1 );
-
-			b64->bv_len = lutil_b64_ntop(
-				(unsigned char *) ctrls[i]->ldctl_value.bv_val,
-				ctrls[i]->ldctl_value.bv_len,
-				b64->bv_val, b64->bv_len );
-		}
-
-		if( b64 ) {
-			len += 1 + b64->bv_len;
-		}
-
-		str = malloc( len + 1 );
-		if ( ldif ) {
-			strcpy( str, ": " );
-		} else {
-			str[0] = '\0';
-		}
-		strcat( str, ctrls[i]->ldctl_oid );
-		strcat( str, ctrls[i]->ldctl_iscritical
-			? " true" : " false" );
-
-		if( b64 ) {
-			strcat(str, " ");
-			strcat(str, b64->bv_val );
-		}
-
-		if ( ldif < 2 ) {
-			write_ldif( ldif ? LDIF_PUT_COMMENT : LDIF_PUT_VALUE,
-				"control", str, len );
-		}
-
-		free( str );
-		ber_bvfree( b64 );
-	}
-}
-
-static int
-write_ldif( int type, char *name, char *value, ber_len_t vallen )
-{
-	char	*ldif;
-
-	if (( ldif = ldif_put( type, name, value, vallen )) == NULL ) {
-		return( -1 );
-	}
-
-	fputs( ldif, stdout );
-	ber_memfree( ldif );
-
-	return( 0 );
-}
-
-
 #ifdef LDAP_CONTROL_PAGEDRESULTS
 static int 
 parse_page_control(
